二叉搜索树：一棵二叉树，可以为空；如果不为空，满足以下性质
1. 非空左子树的所有键值小于其根结点的键值。
2. 非空右子树的所有键值大于其根结点的键值。
3. 左、右子树都是二叉搜索树。

二叉搜索树操作的特别函数：
Position Find( ElementType X, BinTree BST )：从二叉搜索树BST
中查找元素X，返回其所在结点的地址,查找的次数取决于树的高度
	算法思想：
	和二分查找类似，如果大于根元素往右边找，小于根元素网左边找，可以使用递归和非递归的方法实现
		注:对尾递归，可以用循环来实现。

Position FindMin( BinTree BST )：从二叉搜索树BST中查找并返回
最小元素所在结点的地址
	算法思想:最小的元素在二叉搜索树的最左分支的端节点上。一直向左进行递归查找即可

Position FindMax( BinTree BST ) ：从二叉搜索树BST中查找并返回
最大元素所在结点的地址
	算法思想：最小的元素在二叉搜索树的最右分支的端节点上。一直向右进行递归查找即可

BinTree Insert( ElementType X, BinTree BST )
	算法思想：和Find的方法差不多，先找到需要插入的位置，然后进行插入
BinTree Delete( ElementType X, BinTree BST )
	算法思想：分为三种情况
		1.删除的节点是叶子节点：直接删除
		2.删除的节点只有一个孩子:删除该节点，把该节点的唯一的子节点挂到父节点上
		3.该节点是有两个孩子的父节点：我们可以把两个孩子的节点看做是有一个孩子的父节点，但是必须从其子节点找到元素来
		替换他，下面是找元素替换的方法。
			3.1查找该节点左子树的最大元素，把最大元素的值给该节点，然后把那个左子树最大元素的节点删除
			3.2查找该节点右子树的最小元素，把最小元素的值给该节点，然后把那个右子树最小元素的节点删除

			为什么需要找最大或者最小元素呢，因为这样可以最大或者最小元素可以保证该节点只有一个子节点或者没有节点
			否则找到一个具有两个节点的父节点，问题还是没有解决。
		



	
平衡二叉树:对于二叉搜索树来说，搜索的次数取决于树的高度，那么，由于元素的插入顺序和规则的不同
	那么所生成树的形状和高度也不相同。可以参考讲义的十二个月份按照不同规则插入，造成二叉搜索树的高度差异有很大
	我们希望树比较平衡，这样平均查找次数就比较少
	
	定义:
	平衡因子(Balance Factor,简称BF):BF(T)=hl-hr,
	hl和hr为左右子树的高度
	
	平衡二叉树的定义(Balance Binary tree 或者称为AVL树):
		1.空树
		2.任意节点左右子树的高度差不超过1，即|BF|<=1

	那么我们需要思考，n个节点的平衡二叉树的高度为多少呢？能不能满足我们的需求呢。
	我可以找规律，我们指定只有一个节点时，高度为0，那么就有如下规律
		平衡二叉树的高度	平衡二叉树需要的最少节点个数
			0			1		A
			1			2
			2			4
			...			...
			
	具体的规律和证明参考讲义，最终我们得到一个结论：给定节点为N的AVL树的最大高度为O(Log2 N)


	平衡二叉树的调整问题：
	为什么需要调整平衡儿茶树呢？因为我们队平衡二叉树的插入和删除操作，可能会破坏
	树的平衡性，所以我们需要对树的平衡性进行调整。
		详细的平衡二叉树的调整见电子文档 "平衡二叉树的调整策略.doc"
