1.树的引子
	树在分层管理和组织上效率很高。尤其体现在查找上面
	
	1.1查找:根据某个关键字K，从集合R中找出关键字与K相同的记录
		1.1.1查找的分类：
			1.静态查找:集合中的元素是固定的，没有插入和删除操作
			2.动态查找:集合中的元素是动态变化的,除了查找，还可能发生插入和删除操作

		1.1.2静态查找的方法
			顺序查找，时间复制度为O(n)
			二分查找，时间复杂度为O(lg2N)
		
		1.1.3顺序查找引入哨兵算法的概念，减少判断的次数。

		1.1.4可以使用二分查找的方法，但是二分查找要求查找的对象是数组而且数组中元素有序。

		代码路径：E:\project\java_algorithm\C_Algorithem\algorithm01\week03\code\search.c

		由二分查找我们思考：如果我们在安排元素的时候对元素按照层次来进行划分和放置，那我们
		在对此集合进行查找或者其他操作时就很方便了。

		下面举一个例子
				    6
				3         9
			      1	  4	7   10
			    2        5	  8    11
		上面的这是一棵判断树，左子树的节点比父节点小，右子树的节点比父类元素大。每个节点都遵循此规律
		那么如果我们要查找4 我们先查找6(4比6小，肯定在6的左子树)-->3(4比3大肯定在3的右子树)-->4(成功找到)

		如此我们发现，在查找第一层的元素我们需要查找1次，查找第二层需要查找2次，查找第三次的元素需要查找3次.....

		总结规律：
		1.树上每个节点的查找次数刚好为每个节点所在的层数
		2.查找成功时，查找的此时不会超过树的深度
		3.n个节点的判断树的深度为log2 N
		4.ASL=(4*4+4*3+2*2+1)/11=3 平均查找次数=(所有节点的查找次数之和)/总的节点数

		由上面的总结，我们可以获得，此种的数据结构的查找效率不亚于二分查找，而且因为此数据结构对元素进行很好的安排，
		导致在查找的过程中，可以进行插入和删除操作，是一个非常好的数据结构。

2.树的定义
	树，n(n>=0)个节点构成的有限集合,
	当n=0时，为空树
	对于任意一棵非空树，它有以下的性质
		1.树中有一个称为“根（ Root） ”的特殊结点， 用 r 表示；
		2.其余结点可分为m(m>0)个互不相交的有限集T1， T2， ... ， Tm，其中每个集合本身又是一棵树，称为原来树的“子树（ SubTree）”
		具体的定义和性质可以参考讲义。
	
3.树的表示方法
	1.使用链表来表示：这样会存在一个问题，每个节点的子节点不一样，无法进行进行统一的结构体定义
	2.使用最大的子节点定义指针域，这样会存在指针空间浪费的情况
	3.使用儿子--兄弟表示法，可以很好的解决这个问题，具体的参考讲义的图解。
		使用儿子--兄弟表示法，可以很好的把一棵树转换为类似二叉树的形式，所有以后我们的研究对象为二叉树。
